/**
 * HAR File Parser and Validation Utility
 * 
 * This module provides utilities for parsing, validating, and extracting
 * information from HAR (HTTP Archive) files generated by mitmproxy.
 */

const fs = require('fs').promises;
const path = require('path');

class HarParser {
    constructor() {
        this.requiredFields = ['log', 'log.entries', 'log.version'];
    }
    
    /**
     * Parse and validate a HAR file
     * @param {string} harFilePath - Path to the HAR file
     * @returns {Promise<Object>} Parsed HAR data
     */
    async parseHarFile(harFilePath) {
        try {
            const content = await fs.readFile(harFilePath, 'utf8');
            const harData = JSON.parse(content);
            
            // Validate HAR structure
            this.validateHarStructure(harData);
            
            return harData;
        } catch (error) {
            if (error instanceof SyntaxError) {
                throw new Error(`Invalid JSON in HAR file: ${error.message}`);
            }
            throw new Error(`Failed to parse HAR file: ${error.message}`);
        }
    }
    
    /**
     * Validate HAR file structure
     * @param {Object} harData - Parsed HAR data
     * @throws {Error} If HAR structure is invalid
     */
    validateHarStructure(harData) {
        if (!harData || typeof harData !== 'object') {
            throw new Error('HAR data must be an object');
        }
        
        if (!harData.log || typeof harData.log !== 'object') {
            throw new Error('HAR file must contain a log object');
        }
        
        if (!Array.isArray(harData.log.entries)) {
            throw new Error('HAR log must contain an entries array');
        }
        
        if (!harData.log.version) {
            throw new Error('HAR log must specify a version');
        }
    }
    
    /**
     * Extract basic statistics from HAR file
     * @param {string|Object} harInput - Path to HAR file or parsed HAR data
     * @returns {Promise<Object>} HAR statistics
     */
    async getHarStatistics(harInput) {
        const harData = typeof harInput === 'string' 
            ? await this.parseHarFile(harInput)
            : harInput;
        
        const entries = harData.log.entries;
        const stats = {
            totalRequests: entries.length,
            domains: new Set(),
            methods: new Set(),
            statusCodes: {},
            contentTypes: new Set(),
            totalSize: 0,
            totalTime: 0,
            timeRange: { start: null, end: null }
        };
        
        entries.forEach(entry => {
            // Extract domain
            const url = new URL(entry.request.url);
            stats.domains.add(url.hostname);
            
            // Extract method
            stats.methods.add(entry.request.method);
            
            // Track status codes
            const status = entry.response.status;
            stats.statusCodes[status] = (stats.statusCodes[status] || 0) + 1;
            
            // Extract content types
            const contentType = entry.response.headers.find(
                h => h.name.toLowerCase() === 'content-type'
            );
            if (contentType) {
                const type = contentType.value.split(';')[0];
                stats.contentTypes.add(type);
            }
            
            // Calculate total size
            const requestSize = entry.request.bodySize || 0;
            const responseSize = entry.response.bodySize || 0;
            stats.totalSize += requestSize + responseSize;
            
            // Calculate total time
            if (entry.time) {
                stats.totalTime += entry.time;
            }
            
            // Track time range
            const timestamp = new Date(entry.startedDateTime);
            if (!stats.timeRange.start || timestamp < stats.timeRange.start) {
                stats.timeRange.start = timestamp;
            }
            if (!stats.timeRange.end || timestamp > stats.timeRange.end) {
                stats.timeRange.end = timestamp;
            }
        });
        
        // Convert Sets to arrays
        stats.domains = Array.from(stats.domains);
        stats.methods = Array.from(stats.methods);
        stats.contentTypes = Array.from(stats.contentTypes);
        
        // Calculate averages
        stats.averageRequestTime = stats.totalRequests > 0 ? stats.totalTime / stats.totalRequests : 0;
        stats.averageRequestSize = stats.totalRequests > 0 ? stats.totalSize / stats.totalRequests : 0;
        
        return stats;
    }
    
    /**
     * Extract requests by domain
     * @param {string|Object} harInput - Path to HAR file or parsed HAR data
     * @param {string} domain - Domain to filter by (optional)
     * @returns {Promise<Array>} Filtered requests
     */
    async getRequestsByDomain(harInput, domain = null) {
        const harData = typeof harInput === 'string' 
            ? await this.parseHarFile(harInput)
            : harInput;
        
        let entries = harData.log.entries;
        
        if (domain) {
            entries = entries.filter(entry => {
                try {
                    const url = new URL(entry.request.url);
                    return url.hostname === domain || url.hostname.endsWith('.' + domain);
                } catch {
                    return false;
                }
            });
        }
        
        return entries.map(entry => ({
            url: entry.request.url,
            method: entry.request.method,
            status: entry.response.status,
            time: entry.time,
            size: (entry.request.bodySize || 0) + (entry.response.bodySize || 0),
            timestamp: entry.startedDateTime
        }));
    }
    
    /**
     * Extract API endpoints from HAR file
     * @param {string|Object} harInput - Path to HAR file or parsed HAR data
     * @returns {Promise<Object>} API endpoints grouped by domain
     */
    async extractApiEndpoints(harInput) {
        const harData = typeof harInput === 'string' 
            ? await this.parseHarFile(harInput)
            : harInput;
        
        const apiEndpoints = {};
        
        harData.log.entries.forEach(entry => {
            try {
                const url = new URL(entry.request.url);
                const pathSegments = url.pathname.split('/').filter(segment => segment);
                
                // Check if this looks like an API endpoint
                const isApi = pathSegments.some(segment => 
                    segment.toLowerCase().includes('api') ||
                    segment.toLowerCase().includes('v1') ||
                    segment.toLowerCase().includes('v2') ||
                    segment.toLowerCase().includes('graphql')
                );
                
                if (isApi) {
                    const domain = url.hostname;
                    if (!apiEndpoints[domain]) {
                        apiEndpoints[domain] = new Set();
                    }
                    
                    // Extract the API pattern
                    const apiPattern = url.pathname.replace(/\/\d+/g, '/{id}');
                    apiEndpoints[domain].add(`${entry.request.method} ${apiPattern}`);
                }
            } catch {
                // Skip invalid URLs
            }
        });
        
        // Convert Sets to arrays
        Object.keys(apiEndpoints).forEach(domain => {
            apiEndpoints[domain] = Array.from(apiEndpoints[domain]);
        });
        
        return apiEndpoints;
    }
    
    /**
     * Extract headers from HAR file
     * @param {string|Object} harInput - Path to HAR file or parsed HAR data
     * @param {string} headerName - Header name to extract
     * @param {boolean} unique - Return only unique values
     * @returns {Promise<Array>} Header values
     */
    async extractHeaders(harInput, headerName, unique = true) {
        const harData = typeof harInput === 'string' 
            ? await this.parseHarFile(harInput)
            : harInput;
        
        const headerValues = [];
        const headerNameLower = headerName.toLowerCase();
        
        harData.log.entries.forEach(entry => {
            // Check request headers
            entry.request.headers.forEach(header => {
                if (header.name.toLowerCase() === headerNameLower) {
                    headerValues.push(header.value);
                }
            });
            
            // Check response headers
            entry.response.headers.forEach(header => {
                if (header.name.toLowerCase() === headerNameLower) {
                    headerValues.push(header.value);
                }
            });
        });
        
        return unique ? [...new Set(headerValues)] : headerValues;
    }
    
    /**
     * Convert HAR to a simplified format for analysis
     * @param {string|Object} harInput - Path to HAR file or parsed HAR data
     * @returns {Promise<Object>} Simplified HAR data
     */
    async simplifyHar(harInput) {
        const harData = typeof harInput === 'string' 
            ? await this.parseHarFile(harInput)
            : harInput;
        
        return {
            version: harData.log.version,
            creator: harData.log.creator,
            entries: harData.log.entries.map(entry => ({
                id: entry._id || null,
                timestamp: entry.startedDateTime,
                request: {
                    method: entry.request.method,
                    url: entry.request.url,
                    httpVersion: entry.request.httpVersion,
                    headers: entry.request.headers,
                    cookies: entry.request.cookies,
                    queryString: entry.request.queryString,
                    postData: entry.request.postData,
                    headersSize: entry.request.headersSize,
                    bodySize: entry.request.bodySize
                },
                response: {
                    status: entry.response.status,
                    statusText: entry.response.statusText,
                    httpVersion: entry.response.httpVersion,
                    headers: entry.response.headers,
                    cookies: entry.response.cookies,
                    content: entry.response.content,
                    redirectURL: entry.response.redirectURL,
                    headersSize: entry.response.headersSize,
                    bodySize: entry.response.bodySize
                },
                cache: entry.cache,
                timings: entry.timings,
                time: entry.time,
                serverIPAddress: entry.serverIPAddress,
                connection: entry.connection
            }))
        };
    }
    
    /**
     * Validate HAR file against expected format for Integuru
     * @param {string|Object} harInput - Path to HAR file or parsed HAR data
     * @returns {Promise<Object>} Validation result
     */
    async validateForInteguru(harInput) {
        const harData = typeof harInput === 'string' 
            ? await this.parseHarFile(harInput)
            : harInput;
        
        const validation = {
            isValid: true,
            errors: [],
            warnings: []
        };
        
        try {
            this.validateHarStructure(harData);
        } catch (error) {
            validation.isValid = false;
            validation.errors.push(error.message);
            return validation;
        }
        
        // Check for entries
        if (harData.log.entries.length === 0) {
            validation.warnings.push('HAR file contains no network entries');
        }
        
        // Check for required fields in entries
        harData.log.entries.forEach((entry, index) => {
            if (!entry.request || !entry.request.url) {
                validation.warnings.push(`Entry ${index} missing request URL`);
            }
            
            if (!entry.response) {
                validation.warnings.push(`Entry ${index} missing response data`);
            }
        });
        
        // Check for cookies
        const hasCookies = harData.log.entries.some(entry => 
            (entry.request.cookies && entry.request.cookies.length > 0) ||
            (entry.response.cookies && entry.response.cookies.length > 0)
        );
        
        if (!hasCookies) {
            validation.warnings.push('No cookies found in HAR file');
        }
        
        return validation;
    }
}

module.exports = HarParser;