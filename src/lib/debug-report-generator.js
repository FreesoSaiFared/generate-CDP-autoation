/**
 * Debug Report Generator
 * 
 * This module provides comprehensive debug report generation capabilities,
 * including automated analysis, visual insights, and actionable recommendations.
 * 
 * Features:
 * - Comprehensive debug report generation
 * - Multiple report formats (HTML, PDF, JSON, CSV)
 * - Visual analysis integration
 * - Performance impact assessment
 * - Trend analysis and predictions
 * - Executive summary generation
 * - Automated recommendations
 * - Report templates and customization
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const EventEmitter = require('events');

class DebugReportGenerator extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.config = {
            outputDir: options.outputDir || path.join(process.cwd(), 'debug', 'reports'),
            templateDir: options.templateDir || path.join(__dirname, 'templates'),
            includeVisualAnalysis: options.includeVisualAnalysis !== false,
            includePerformanceMetrics: options.includePerformanceMetrics !== false,
            includeErrorAnalysis: options.includeErrorAnalysis !== false,
            includeTrendAnalysis: options.includeTrendAnalysis !== false,
            includeRecommendations: options.includeRecommendations !== false,
            enableCompression: options.enableCompression !== false,
            defaultFormat: options.defaultFormat || 'html',
            customTemplates: options.customTemplates || {},
            branding: options.branding || {
                title: 'CDP Automation Debug Report',
                logo: null,
                company: 'Automation Team',
                footer: 'Generated by CDP Automation Debug Infrastructure'
            }
        };
        
        // Report templates
        this.templates = {
            html: null,
            pdf: null,
            json: null,
            csv: null
        };
        
        // Initialize templates
        this.initializeTemplates();
        
        // Initialize output directory
        this.initializeOutputDirectory();
    }

    /**
     * Generate comprehensive debug report
     * 
     * @param {Object} params - Report parameters
     * @param {string} params.sessionId - Debug session ID
     * @param {Object} params.debugData - Debug session data
     * @param {Object} params.performanceData - Performance metrics
     * @param {Object} params.errorData - Error analysis data
     * @param {Object} params.visualData - Visual analysis data
     * @param {Object} params.options - Report generation options
     * @returns {Promise<Object>} Generated report information
     */
    async generateReport(params) {
        const {
            sessionId,
            debugData,
            performanceData,
            errorData,
            visualData,
            options = {}
        } = params;
        
        try {
            const reportId = this.generateReportId();
            const timestamp = new Date().toISOString();
            
            // Build comprehensive report data
            const reportData = await this.buildReportData({
                reportId,
                timestamp,
                sessionId,
                debugData,
                performanceData,
                errorData,
                visualData,
                options
            });
            
            // Generate reports in different formats
            const generatedReports = {};
            
            const formats = options.formats || [this.config.defaultFormat];
            
            for (const format of formats) {
                generatedReports[format] = await this.generateReportFormat(
                    format,
                    reportData,
                    options
                );
            }
            
            // Create report summary
            const summary = this.generateReportSummary(generatedReports, reportData);
            
            const result = {
                reportId,
                timestamp,
                sessionId,
                formats: generatedReports,
                summary,
                reportData
            };
            
            this.emit('report:generated', result);
            
            return result;
            
        } catch (error) {
            this.emit('report:error', { sessionId, error });
            throw new Error(`Failed to generate report: ${error.message}`);
        }
    }

    /**
     * Generate batch reports for multiple sessions
     * 
     * @param {Object} params - Batch report parameters
     * @param {Array} params.sessionIds - Session IDs to include
     * @param {Object} params.dataSources - Data sources for sessions
     * @param {Object} params.options - Report generation options
     * @returns {Promise<Object>} Batch report information
     */
    async generateBatchReport(params) {
        const {
            sessionIds,
            dataSources,
            options = {}
        } = params;
        
        const reportId = this.generateReportId();
        const timestamp = new Date().toISOString();
        
        try {
            // Collect data for all sessions
            const sessionReports = [];
            
            for (const sessionId of sessionIds) {
                const sessionData = await this.collectSessionData(sessionId, dataSources);
                
                if (sessionData) {
                    sessionReports.push({
                        sessionId,
                        ...sessionData
                    });
                }
            }
            
            // Generate batch report data
            const batchReportData = await this.buildBatchReportData({
                reportId,
                timestamp,
                sessionReports,
                options
            });
            
            // Generate batch reports
            const formats = options.formats || [this.config.defaultFormat];
            const generatedReports = {};
            
            for (const format of formats) {
                generatedReports[format] = await this.generateReportFormat(
                    format,
                    batchReportData,
                    options
                );
            }
            
            const result = {
                reportId,
                timestamp,
                sessionCount: sessionReports.length,
                sessionIds,
                formats: generatedReports,
                summary: this.generateBatchReportSummary(generatedReports, batchReportData)
            };
            
            this.emit('batch_report:generated', result);
            
            return result;
            
        } catch (error) {
            this.emit('batch_report:error', { sessionIds, error });
            throw new Error(`Failed to generate batch report: ${error.message}`);
        }
    }

    /**
     * Generate executive summary report
     * 
     * @param {Object} params - Executive summary parameters
     * @param {string} params.timeRange - Time range for summary
     * @param {Object} params.options - Summary options
     * @returns {Promise<Object>} Executive summary
     */
    async generateExecutiveSummary(params) {
        const {
            timeRange = '24h', // Default to last 24 hours
            options = {}
        } = params;
        
        try {
            // Collect summary data
            const summaryData = await this.collectSummaryData(timeRange);
            
            // Generate executive summary
            const executiveSummary = {
                reportId: this.generateReportId(),
                timestamp: new Date().toISOString(),
                timeRange,
                overview: this.generateOverview(summaryData),
                keyMetrics: this.generateKeyMetrics(summaryData),
                trends: this.generateTrends(summaryData),
                issues: this.generateIssues(summaryData),
                recommendations: this.generateRecommendations(summaryData),
                actionItems: this.generateActionItems(summaryData)
            };
            
            // Generate executive summary in requested format
            const format = options.format || 'html';
            const generatedReport = await this.generateReportFormat(
                format,
                executiveSummary,
                { ...options, template: 'executive_summary' }
            );
            
            const result = {
                reportId: executiveSummary.reportId,
                timestamp: executiveSummary.timestamp,
                timeRange,
                format,
                report: generatedReport,
                summary: executiveSummary
            };
            
            this.emit('executive_summary:generated', result);
            
            return result;
            
        } catch (error) {
            this.emit('executive_summary:error', { timeRange, error });
            throw new Error(`Failed to generate executive summary: ${error.message}`);
        }
    }

    /**
     * Get available report templates
     * 
     * @returns {Object} Available templates
     */
    getAvailableTemplates() {
        return {
            default: Object.keys(this.templates),
            custom: Object.keys(this.config.customTemplates),
            formats: {
                html: 'HTML Report - Interactive and detailed',
                pdf: 'PDF Report - Printable and shareable',
                json: 'JSON Report - Machine-readable',
                csv: 'CSV Report - Spreadsheet compatible'
            }
        };
    }

    /**
     * Register custom report template
     * 
     * @param {string} name - Template name
     * @param {string} format - Report format
     * @param {string} template - Template content
     * @returns {Promise<boolean>} Success status
     */
    async registerTemplate(name, format, template) {
        try {
            if (!this.config.customTemplates[format]) {
                this.config.customTemplates[format] = {};
            }
            
            this.config.customTemplates[format][name] = template;
            
            // Save custom templates
            await this.saveCustomTemplates();
            
            this.emit('template:registered', { name, format });
            return true;
            
        } catch (error) {
            this.emit('template:error', { name, format, error });
            return false;
        }
    }

    // Private helper methods

    async initializeTemplates() {
        // Load default templates
        this.templates.html = await this.loadTemplate('html');
        this.templates.pdf = await this.loadTemplate('pdf');
        this.templates.json = await this.loadTemplate('json');
        this.templates.csv = await this.loadTemplate('csv');
        
        // Load custom templates
        await this.loadCustomTemplates();
    }

    async loadTemplate(format) {
        const templatePath = path.join(this.config.templateDir, `${format}.template`);
        
        try {
            return await fs.readFile(templatePath, 'utf8');
        } catch {
            // Return default template if file doesn't exist
            return this.getDefaultTemplate(format);
        }
    }

    getDefaultTemplate(format) {
        switch (format) {
            case 'html':
                return this.getDefaultHTMLTemplate();
            case 'pdf':
                return this.getDefaultPDFTemplate();
            case 'json':
                return this.getDefaultJSONTemplate();
            case 'csv':
                return this.getDefaultCSVTemplate();
            default:
                return '';
        }
    }

    getDefaultHTMLTemplate() {
        return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .header { background: #333; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .section { background: white; margin-bottom: 20px; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metric { display: flex; justify-content: space-between; margin-bottom: 10px; }
        .chart { height: 300px; margin: 20px 0; }
        .error { color: #d32f2f; }
        .warning { color: #f57c00; }
        .success { color: #38a169; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{title}}</h1>
        <p>Generated: {{timestamp}}</p>
        <p>Session ID: {{sessionId}}</p>
    </div>
    
    {{#sections}}
    <div class="section">
        <h2>{{title}}</h2>
        {{content}}
    </div>
    {{/sections}}
    
    <div class="section">
        <h2>Recommendations</h2>
        <ul>
        {{#recommendations}}
        <li>{{.}}</li>
        {{/recommendations}}
        </ul>
    </div>
</body>
</html>
        `;
    }

    getDefaultPDFTemplate() {
        return `
# {{title}}

Generated: {{timestamp}}
Session ID: {{sessionId}}

{{#sections}}
## {{title}}

{{content}}

{{/sections}}

## Recommendations

{{#recommendations}}
- {{.}}
{{/recommendations}}
        `;
    }

    getDefaultJSONTemplate() {
        return `
{
  "reportId": "{{reportId}}",
  "timestamp": "{{timestamp}}",
  "sessionId": "{{sessionId}}",
  "title": "{{title}}",
  "sections": {{sections}},
  "recommendations": {{recommendations}}
}
        `;
    }

    getDefaultCSVTemplate() {
        return `
Section,Metric,Value,Timestamp
{{#sections}}
{{title}},{{content}},{{timestamp}}
{{/sections}}
        `;
    }

    async initializeOutputDirectory() {
        try {
            await fs.access(this.config.outputDir);
        } catch {
            await fs.mkdir(this.config.outputDir, { recursive: true });
        }
    }

    async buildReportData(params) {
        const {
            reportId,
            timestamp,
            sessionId,
            debugData,
            performanceData,
            errorData,
            visualData,
            options
        } = params;
        
        const reportData = {
            reportId,
            timestamp,
            sessionId,
            title: this.config.branding.title,
            metadata: {
                generatedBy: 'CDP Automation Debug Infrastructure',
                version: '1.0.0',
                format: options.format || this.config.defaultFormat
            },
            sections: []
        };
        
        // Add overview section
        reportData.sections.push({
            id: 'overview',
            title: 'Overview',
            content: this.generateOverviewSection({
                debugData,
                performanceData,
                errorData,
                visualData
            })
        });
        
        // Add debug session section
        if (debugData) {
            reportData.sections.push({
                id: 'debug_session',
                title: 'Debug Session Details',
                content: this.generateDebugSessionSection(debugData)
            });
        }
        
        // Add performance metrics section
        if (this.config.includePerformanceMetrics && performanceData) {
            reportData.sections.push({
                id: 'performance',
                title: 'Performance Metrics',
                content: this.generatePerformanceSection(performanceData)
            });
        }
        
        // Add error analysis section
        if (this.config.includeErrorAnalysis && errorData) {
            reportData.sections.push({
                id: 'errors',
                title: 'Error Analysis',
                content: this.generateErrorSection(errorData)
            });
        }
        
        // Add visual analysis section
        if (this.config.includeVisualAnalysis && visualData) {
            reportData.sections.push({
                id: 'visual',
                title: 'Visual Analysis',
                content: this.generateVisualSection(visualData)
            });
        }
        
        // Add recommendations section
        if (this.config.includeRecommendations) {
            const recommendations = this.generateRecommendations({
                debugData,
                performanceData,
                errorData,
                visualData
            });
            
            reportData.recommendations = recommendations;
        }
        
        return reportData;
    }

    generateOverviewSection(data) {
        const { debugData, performanceData, errorData, visualData } = data;
        
        let overview = '<div class="overview-metrics">';
        
        // Debug session overview
        if (debugData) {
            overview += `
                <div class="metric">
                    <span>Debug Session Status:</span>
                    <span class="${debugData.resolved ? 'success' : 'error'}">
                        ${debugData.resolved ? 'Resolved' : 'Failed'}
                    </span>
                </div>
                <div class="metric">
                    <span>Total Attempts:</span>
                    <span>${debugData.attempts ? debugData.attempts.length : 0}</span>
                </div>
                <div class="metric">
                    <span>Duration:</span>
                    <span>${debugData.duration ? debugData.duration.toFixed(2) + 's' : 'N/A'}</span>
                </div>
            `;
        }
        
        // Performance overview
        if (performanceData) {
            overview += `
                <div class="metric">
                    <span>Average Response Time:</span>
                    <span>${performanceData.avgResponseTime || 'N/A'}ms</span>
                </div>
                <div class="metric">
                    <span>Success Rate:</span>
                    <span>${performanceData.successRate ? (performanceData.successRate * 100).toFixed(1) + '%' : 'N/A'}</span>
                </div>
            `;
        }
        
        // Error overview
        if (errorData) {
            overview += `
                <div class="metric">
                    <span>Total Errors:</span>
                    <span class="error">${errorData.totalErrors || 0}</span>
                </div>
                <div class="metric">
                    <span>Critical Errors:</span>
                    <span class="${(errorData.criticalErrors || 0) > 0 ? 'error' : 'success'}">
                        ${errorData.criticalErrors || 0}
                    </span>
                </div>
            `;
        }
        
        overview += '</div>';
        
        return overview;
    }

    generateDebugSessionSection(debugData) {
        let content = '';
        
        if (debugData.attempts && debugData.attempts.length > 0) {
            content += '<h3>Attempt History</h3>';
            content += '<table>';
            content += '<tr><th>Attempt</th><th>Strategy</th><th>Duration</th><th>Result</th><th>Error</th></tr>';
            
            debugData.attempts.forEach((attempt, index) => {
                const statusClass = attempt.success ? 'success' : 'error';
                content += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${attempt.strategy || 'N/A'}</td>
                        <td>${attempt.duration ? attempt.duration + 'ms' : 'N/A'}</td>
                        <td class="${statusClass}">${attempt.success ? 'Success' : 'Failed'}</td>
                        <td class="error">${attempt.error ? attempt.error.message : 'N/A'}</td>
                    </tr>
                `;
            });
            
            content += '</table>';
        }
        
        if (debugData.learnedLessons && debugData.learnedLessons.length > 0) {
            content += '<h3>Learned Lessons</h3>';
            content += '<ul>';
            debugData.learnedLessons.forEach(lesson => {
                content += `<li><strong>${lesson.type}:</strong> ${lesson.description}</li>`;
            });
            content += '</ul>';
        }
        
        return content;
    }

    generatePerformanceSection(performanceData) {
        let content = '';
        
        // Performance metrics table
        content += '<h3>Performance Metrics</h3>';
        content += '<table>';
        content += '<tr><th>Metric</th><th>Value</th><th>Status</th></tr>';
        
        const metrics = [
            { name: 'Total Executions', value: performanceData.totalExecutions || 0, status: 'info' },
            { name: 'Success Rate', value: performanceData.successRate ? (performanceData.successRate * 100).toFixed(1) + '%' : 'N/A', status: performanceData.successRate > 0.9 ? 'success' : performanceData.successRate > 0.7 ? 'warning' : 'error' },
            { name: 'Average Response Time', value: (performanceData.avgResponseTime || 0) + 'ms', status: performanceData.avgResponseTime < 1000 ? 'success' : performanceData.avgResponseTime < 5000 ? 'warning' : 'error' },
            { name: 'CPU Usage', value: (performanceData.cpuUsage || 0) + '%', status: performanceData.cpuUsage < 80 ? 'success' : performanceData.cpuUsage < 90 ? 'warning' : 'error' },
            { name: 'Memory Usage', value: (performanceData.memoryUsage || 0) + '%', status: performanceData.memoryUsage < 85 ? 'success' : performanceData.memoryUsage < 95 ? 'warning' : 'error' }
        ];
        
        metrics.forEach(metric => {
            content += `
                <tr>
                    <td>${metric.name}</td>
                    <td>${metric.value}</td>
                    <td class="${metric.status}">${this.getStatusIndicator(metric.status)}</td>
                </tr>
            `;
        });
        
        content += '</table>';
        
        // Performance chart data (placeholder)
        content += '<div class="chart" id="performance-chart"></div>';
        
        return content;
    }

    generateErrorSection(errorData) {
        let content = '';
        
        // Error summary
        content += '<h3>Error Summary</h3>';
        content += '<table>';
        content += '<tr><th>Category</th><th>Count</th><th>Percentage</th><th>Trend</th></tr>';
        
        if (errorData.byCategory) {
            Object.keys(errorData.byCategory).forEach(category => {
                const error = errorData.byCategory[category];
                const percentage = (error.count / errorData.totalErrors * 100).toFixed(1);
                const trendClass = error.trend === 'increasing' ? 'error' : error.trend === 'decreasing' ? 'success' : 'warning';
                
                content += `
                    <tr>
                        <td>${category}</td>
                        <td>${error.count}</td>
                        <td>${percentage}%</td>
                        <td class="${trendClass}">${error.trend || 'stable'}</td>
                    </tr>
                `;
            });
        }
        
        content += '</table>';
        
        // Top errors
        if (errorData.topErrors && errorData.topErrors.length > 0) {
            content += '<h3>Top Errors</h3>';
            content += '<ol>';
            errorData.topErrors.forEach((error, index) => {
                content += `
                    <li>
                        <strong>${error.message}</strong><br>
                        <small>Occurrences: ${error.count} | Category: ${error.category}</small>
                    </li>
                `;
            });
            content += '</ol>';
        }
        
        return content;
    }

    generateVisualSection(visualData) {
        let content = '';
        
        // Visual verification results
        if (visualData.screenshots && visualData.screenshots.length > 0) {
            content += '<h3>Visual Verification Results</h3>';
            content += '<div class="screenshots">';
            
            visualData.screenshots.forEach((screenshot, index) => {
                const statusClass = screenshot.success ? 'success' : 'error';
                content += `
                    <div class="screenshot">
                        <h4>Screenshot ${index + 1}</h4>
                        <p><strong>Status:</strong> <span class="${statusClass}">${screenshot.success ? 'Passed' : 'Failed'}</span></p>
                        <p><strong>Confidence:</strong> ${(screenshot.confidence || 0).toFixed(2)}</p>
                        ${screenshot.issues && screenshot.issues.length > 0 ? `
                            <p><strong>Issues:</strong></p>
                            <ul>
                                ${screenshot.issues.map(issue => `<li>${issue}</li>`).join('')}
                            </ul>
                        ` : ''}
                    </div>
                `;
            });
            
            content += '</div>';
        }
        
        // Element detection results
        if (visualData.elements) {
            content += '<h3>Element Detection</h3>';
            content += '<table>';
            content += '<tr><th>Element Type</th><th>Expected</th><th>Found</th><th>Status</th></tr>';
            
            Object.keys(visualData.elements).forEach(elementType => {
                const element = visualData.elements[elementType];
                const statusClass = element.found === element.expected ? 'success' : 'error';
                
                content += `
                    <tr>
                        <td>${elementType}</td>
                        <td>${element.expected}</td>
                        <td>${element.found}</td>
                        <td class="${statusClass}">${element.found === element.expected ? 'Match' : 'Mismatch'}</td>
                    </tr>
                `;
            });
            
            content += '</table>';
        }
        
        return content;
    }

    generateRecommendations(data) {
        const recommendations = [];
        
        // Analyze all data sources for recommendations
        const { debugData, performanceData, errorData, visualData } = data;
        
        // Debug-based recommendations
        if (debugData && !debugData.resolved) {
            recommendations.push({
                priority: 'high',
                category: 'debug_process',
                title: 'Debug Process Optimization',
                description: 'Consider increasing the maximum attempt limit or implementing more sophisticated debugging strategies',
                action: 'Review and enhance debugging algorithms'
            });
        }
        
        // Performance-based recommendations
        if (performanceData) {
            if (performanceData.successRate < 0.8) {
                recommendations.push({
                    priority: 'high',
                    category: 'performance',
                    title: 'Low Success Rate',
                    description: `Success rate is ${(performanceData.successRate * 100).toFixed(1)}%, which is below acceptable levels`,
                    action: 'Investigate performance bottlenecks and optimize execution paths'
                });
            }
            
            if (performanceData.avgResponseTime > 5000) {
                recommendations.push({
                    priority: 'medium',
                    category: 'performance',
                    title: 'High Response Times',
                    description: `Average response time is ${performanceData.avgResponseTime}ms, which may impact user experience`,
                    action: 'Optimize slow operations and implement caching'
                });
            }
        }
        
        // Error-based recommendations
        if (errorData && errorData.criticalErrors > 0) {
            recommendations.push({
                priority: 'critical',
                category: 'error_handling',
                title: 'Critical Errors Detected',
                description: `${errorData.criticalErrors} critical errors require immediate attention`,
                action: 'Implement robust error handling and monitoring'
            });
        }
        
        // Visual-based recommendations
        if (visualData) {
            const failedScreenshots = visualData.screenshots ? visualData.screenshots.filter(s => !s.success).length : 0;
            
            if (failedScreenshots > 0) {
                recommendations.push({
                    priority: 'medium',
                    category: 'visual_verification',
                    title: 'Visual Verification Failures',
                    description: `${failedScreenshots} screenshots failed visual verification`,
                    action: 'Review element selectors and page load conditions'
                });
            }
        }
        
        // Sort recommendations by priority
        recommendations.sort((a, b) => {
            const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
            return priorityOrder[b.priority] - priorityOrder[a.priority];
        });
        
        return recommendations.map(rec => rec.title);
    }

    async generateReportFormat(format, reportData, options) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `${reportData.reportId}_${timestamp}.${format}`;
        const filepath = path.join(this.config.outputDir, filename);
        
        let content;
        let template;
        
        // Use custom template if available
        if (options.template && this.config.customTemplates[format] && this.config.customTemplates[format][options.template]) {
            template = this.config.customTemplates[format][options.template];
        } else {
            template = this.templates[format];
        }
        
        // Process template
        if (template) {
            content = this.processTemplate(template, reportData);
        } else {
            // Fallback to simple format
            content = this.generateSimpleFormat(format, reportData);
        }
        
        // Write to file
        await fs.writeFile(filepath, content);
        
        // Compress if enabled
        if (this.config.enableCompression && format !== 'json') {
            await this.compressReport(filepath);
        }
        
        return {
            format,
            filename,
            filepath,
            size: content.length
        };
    }

    processTemplate(template, data) {
        // Simple template processing (in production, use a proper template engine)
        let processed = template;
        
        // Replace simple placeholders
        processed = processed.replace(/\{\{title\}\}/g, data.title);
        processed = processed.replace(/\{\{timestamp\}\}/g, data.timestamp);
        processed = processed.replace(/\{\{sessionId\}\}/g, data.sessionId);
        processed = processed.replace(/\{\{reportId\}\}/g, data.reportId);
        
        // Handle sections (simplified)
        if (data.sections && Array.isArray(data.sections)) {
            const sectionsHtml = data.sections.map(section => 
                `<div class="section">
                    <h2>${section.title}</h2>
                    ${section.content}
                </div>`
            ).join('\n');
            
            processed = processed.replace(/\{\{#sections\}\}.*\{\{\/sections\}\}/g, sectionsHtml);
        }
        
        // Handle recommendations
        if (data.recommendations && Array.isArray(data.recommendations)) {
            const recommendationsHtml = data.recommendations.map(rec => `<li>${rec}</li>`).join('\n');
            processed = processed.replace(/\{\{#recommendations\}\}.*\{\{\/recommendations\}\}/g, recommendationsHtml);
        }
        
        return processed;
    }

    generateSimpleFormat(format, data) {
        switch (format) {
            case 'json':
                return JSON.stringify(data, null, 2);
            case 'csv':
                return this.generateCSVFormat(data);
            default:
                return JSON.stringify(data, null, 2);
        }
    }

    generateCSVFormat(data) {
        const csvLines = ['Report,Data,Value,Timestamp'];
        
        if (data.sections) {
            data.sections.forEach(section => {
                csvLines.push(`${section.title},Content,${section.content},${data.timestamp}`);
            });
        }
        
        if (data.recommendations) {
            data.recommendations.forEach(rec => {
                csvLines.push(`Recommendations,Item,${rec},${data.timestamp}`);
            });
        }
        
        return csvLines.join('\n');
    }

    generateReportSummary(generatedReports, reportData) {
        return {
            formats: Object.keys(generatedReports),
            totalSize: Object.values(generatedReports).reduce((sum, report) => sum + report.size, 0),
            sections: reportData.sections ? reportData.sections.length : 0,
            recommendations: reportData.recommendations ? reportData.recommendations.length : 0,
            generatedAt: new Date().toISOString()
        };
    }

    generateReportId() {
        return `report_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
    }

    getStatusIndicator(status) {
        const indicators = {
            success: '✅',
            warning: '⚠️',
            error: '❌',
            info: 'ℹ️'
        };
        
        return indicators[status] || indicators.info;
    }

    async compressReport(filepath) {
        // Simple compression placeholder
        // In production, implement proper compression
        console.log(`Report compression not implemented for: ${filepath}`);
    }

    async saveCustomTemplates() {
        const templatesPath = path.join(this.config.outputDir, 'custom-templates.json');
        await fs.writeFile(templatesPath, JSON.stringify(this.config.customTemplates, null, 2));
    }

    async loadCustomTemplates() {
        const templatesPath = path.join(this.config.outputDir, 'custom-templates.json');
        
        try {
            const data = await fs.readFile(templatesPath, 'utf8');
            this.config.customTemplates = JSON.parse(data);
        } catch {
            // File doesn't exist or is invalid
            this.config.customTemplates = {};
        }
    }

    // Batch report methods (simplified)

    async buildBatchReportData(params) {
        const { reportId, timestamp, sessionReports, options } = params;
        
        return {
            reportId,
            timestamp,
            title: `Batch Debug Report - ${sessionReports.length} Sessions`,
            metadata: {
                generatedBy: 'CDP Automation Debug Infrastructure',
                version: '1.0.0',
                sessionCount: sessionReports.length
            },
            sections: [
                {
                    id: 'batch_overview',
                    title: 'Batch Overview',
                    content: this.generateBatchOverview(sessionReports)
                },
                {
                    id: 'session_summary',
                    title: 'Session Summary',
                    content: this.generateSessionSummaryTable(sessionReports)
                }
            ],
            recommendations: this.generateBatchRecommendations(sessionReports)
        };
    }

    generateBatchOverview(sessionReports) {
        const totalSessions = sessionReports.length;
        const resolvedSessions = sessionReports.filter(s => s.resolved).length;
        const successRate = totalSessions > 0 ? (resolvedSessions / totalSessions) * 100 : 0;
        
        return `
            <div class="metric">
                <span>Total Sessions:</span>
                <span>${totalSessions}</span>
            </div>
            <div class="metric">
                <span>Resolved Sessions:</span>
                <span class="${successRate > 80 ? 'success' : successRate > 60 ? 'warning' : 'error'}">${resolvedSessions}</span>
            </div>
            <div class="metric">
                <span>Success Rate:</span>
                <span>${successRate.toFixed(1)}%</span>
            </div>
        `;
    }

    generateSessionSummaryTable(sessionReports) {
        let table = '<table>';
        table += '<tr><th>Session ID</th><th>Status</th><th>Attempts</th><th>Duration</th></tr>';
        
        sessionReports.forEach(session => {
            const statusClass = session.resolved ? 'success' : 'error';
            table += `
                <tr>
                    <td>${session.sessionId}</td>
                    <td class="${statusClass}">${session.resolved ? 'Resolved' : 'Failed'}</td>
                    <td>${session.attempts ? session.attempts.length : 0}</td>
                    <td>${session.duration ? session.duration.toFixed(2) + 's' : 'N/A'}</td>
                </tr>
            `;
        });
        
        table += '</table>';
        return table;
    }

    generateBatchRecommendations(sessionReports) {
        const recommendations = [];
        
        // Analyze batch performance
        const avgSuccessRate = sessionReports.reduce((sum, s) => sum + (s.resolved ? 1 : 0), 0) / sessionReports.length;
        
        if (avgSuccessRate < 0.8) {
            recommendations.push('Review debugging strategies across all sessions');
        }
        
        if (avgSuccessRate < 0.6) {
            recommendations.push('Consider comprehensive system review and optimization');
        }
        
        return recommendations;
    }

    generateBatchReportSummary(generatedReports, batchReportData) {
        return {
            formats: Object.keys(generatedReports),
            totalSize: Object.values(generatedReports).reduce((sum, report) => sum + report.size, 0),
            sessionCount: batchReportData.metadata.sessionCount,
            generatedAt: new Date().toISOString()
        };
    }

    // Executive summary methods (simplified)

    async collectSummaryData(timeRange) {
        // This would collect data from various sources
        // For now, return placeholder data
        return {
            totalSessions: 0,
            resolvedSessions: 0,
            averageAttempts: 0,
            topErrors: [],
            performanceMetrics: {}
        };
    }

    generateOverview(summaryData) {
        return {
            totalSessions: summaryData.totalSessions,
            resolvedSessions: summaryData.resolvedSessions,
            successRate: summaryData.totalSessions > 0 ? 
                (summaryData.resolvedSessions / summaryData.totalSessions) * 100 : 0,
            status: summaryData.resolvedSessions / summaryData.totalSessions > 0.8 ? 'Healthy' : 'Needs Attention'
        };
    }

    generateKeyMetrics(summaryData) {
        return {
            averageAttempts: summaryData.averageAttempts,
            topError: summaryData.topErrors[0] || 'None',
            performance: summaryData.performanceMetrics
        };
    }

    generateTrends(summaryData) {
        return {
            sessionTrend: 'stable',
            errorTrend: 'decreasing',
            performanceTrend: 'improving'
        };
    }

    generateIssues(summaryData) {
        return {
            critical: summaryData.topErrors.filter(e => e.severity === 'critical').length,
            warnings: summaryData.topErrors.filter(e => e.severity === 'high').length,
            recommendations: summaryData.topErrors.length > 5
        };
    }

    generateActionItems(summaryData) {
        return [
            'Monitor critical error patterns',
            'Optimize debugging strategies',
            'Review performance metrics',
            'Update error handling procedures'
        ];
    }
}

module.exports = DebugReportGenerator;