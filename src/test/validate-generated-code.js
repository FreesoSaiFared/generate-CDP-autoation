/**
 * Validation Script for Generated Code
 * 
 * This script validates Python code generated by Integuru for:
 * - Security vulnerabilities
 * - Code quality and best practices
 * - Performance considerations
 * - API usage patterns
 * - Error handling
 * - Documentation completeness
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

class CodeValidator {
  constructor(options = {}) {
    this.rules = options.rules || this.getDefaultRules();
    this.severityLevels = ['critical', 'high', 'medium', 'low'];
    this.issues = [];
  }

  /**
   * Validate generated Python code
   * 
   * @param {string} code - Python code to validate
   * @param {Object} context - Context about the code (API endpoints, etc.)
   * @returns {Object} Validation results
   */
  async validate(code, context = {}) {
    this.issues = [];
    
    // Run all validation rules
    for (const rule of this.rules) {
      try {
        await rule.validate(code, context, this);
      } catch (error) {
        this.addIssue('critical', 'validator_error', `Validation rule failed: ${error.message}`, {
          rule: rule.name,
          error: error.message
        });
      }
    }
    
    // Generate summary
    const summary = this.generateSummary();
    
    return {
      valid: summary.critical === 0 && summary.high === 0,
      summary,
      issues: this.issues,
      recommendations: this.generateRecommendations(),
      score: this.calculateQualityScore()
    };
  }

  /**
   * Add validation issue
   * 
   * @param {string} severity - Issue severity
   * @param {string} type - Issue type
   * @param {string} message - Issue description
   * @param {Object} metadata - Additional metadata
   */
  addIssue(severity, type, message, metadata = {}) {
    if (!this.severityLevels.includes(severity)) {
      throw new Error(`Invalid severity level: ${severity}`);
    }
    
    this.issues.push({
      severity,
      type,
      message,
      metadata,
      timestamp: new Date()
    });
  }

  /**
   * Generate summary of issues by severity
   * 
   * @returns {Object} Issue summary
   */
  generateSummary() {
    const summary = {};
    
    this.severityLevels.forEach(level => {
      summary[level] = this.issues.filter(issue => issue.severity === level).length;
    });
    
    summary.total = this.issues.length;
    
    return summary;
  }

  /**
   * Generate recommendations based on issues
   * 
   * @returns {Array} Array of recommendations
   */
  generateRecommendations() {
    const recommendations = [];
    const issueTypes = new Set(this.issues.map(issue => issue.type));
    
    if (issueTypes.has('hardcoded_credentials')) {
      recommendations.push({
        type: 'security',
        priority: 'critical',
        title: 'Remove Hardcoded Credentials',
        description: 'Replace hardcoded credentials with environment variables or secure configuration'
      });
    }
    
    if (issueTypes.has('missing_error_handling')) {
      recommendations.push({
        type: 'reliability',
        priority: 'high',
        title: 'Add Error Handling',
        description: 'Implement proper try-catch blocks and handle API errors gracefully'
      });
    }
    
    if (issueTypes.has('insecure_ssl')) {
      recommendations.push({
        type: 'security',
        priority: 'high',
        title: 'Enable SSL Verification',
        description: 'Ensure SSL certificate verification is enabled for all HTTPS requests'
      });
    }
    
    if (issueTypes.has('missing_timeout')) {
      recommendations.push({
        type: 'performance',
        priority: 'medium',
        title: 'Add Request Timeouts',
        description: 'Set appropriate timeouts for network requests to prevent hanging'
      });
    }
    
    if (issueTypes.has('missing_rate_limiting')) {
      recommendations.push({
        type: 'performance',
        priority: 'medium',
        title: 'Implement Rate Limiting',
        description: 'Add delays or rate limiting to avoid overwhelming the API'
      });
    }
    
    return recommendations;
  }

  /**
   * Calculate overall quality score
   * 
   * @returns {number} Quality score (0-100)
   */
  calculateQualityScore() {
    const summary = this.generateSummary();
    
    // Weight different severity levels
    const weights = {
      critical: 10,
      high: 5,
      medium: 2,
      low: 1
    };
    
    let totalWeight = 0;
    this.severityLevels.forEach(level => {
      totalWeight += summary[level] * weights[level];
    });
    
    // Calculate score (100 is perfect)
    const score = Math.max(0, 100 - totalWeight);
    
    return Math.round(score);
  }

  /**
   * Get default validation rules
   * 
   * @returns {Array} Array of validation rules
   */
  getDefaultRules() {
    return [
      new SecurityRule(),
      new ErrorHandlingRule(),
      new PerformanceRule(),
      new CodeQualityRule(),
      new ApiUsageRule(),
      new DocumentationRule()
    ];
  }
}

/**
 * Security validation rule
 */
class SecurityRule {
  get name() {
    return 'security';
  }

  async validate(code, context, validator) {
    // Check for hardcoded credentials
    const credentialPatterns = [
      /password\s*=\s*['"][^'"]+['"]/gi,
      /api_key\s*=\s*['"][^'"]+['"]/gi,
      /secret\s*=\s*['"][^'"]+['"]/gi,
      /token\s*=\s*['"][^'"]+['"]/gi,
      /auth\s*=\s*['"][^'"]+['"]/gi
    ];
    
    credentialPatterns.forEach(pattern => {
      const matches = code.match(pattern);
      if (matches) {
        matches.forEach(match => {
          validator.addIssue('critical', 'hardcoded_credentials', 
            'Hardcoded credential detected', {
              match: match,
              line: this.getLineNumber(code, match)
            });
        });
      }
    });
    
    // Check for SSL verification disabled
    if (code.includes('verify=False') || code.includes('ssl_verify=False')) {
      validator.addIssue('high', 'insecure_ssl', 
        'SSL verification is disabled', {
          recommendation: 'Remove verify=False or set to True'
        });
    }
    
    // Check for unsafe eval/exec
    if (code.includes('eval(') || code.includes('exec(')) {
      validator.addIssue('critical', 'unsafe_code_execution', 
        'Unsafe code execution (eval/exec) detected');
    }
    
    // Check for shell command execution
    const shellPatterns = [
      /os\.system/gi,
      /subprocess\.call/gi,
      /subprocess\.run/gi
    ];
    
    shellPatterns.forEach(pattern => {
      if (pattern.test(code)) {
        validator.addIssue('high', 'shell_command_execution', 
          'Shell command execution detected', {
            pattern: pattern.source
          });
      }
    });
  }

  getLineNumber(code, match) {
    const lines = code.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(match)) {
        return i + 1;
      }
    }
    return null;
  }
}

/**
 * Error handling validation rule
 */
class ErrorHandlingRule {
  get name() {
    return 'error_handling';
  }

  async validate(code, context, validator) {
    // Check for try-catch blocks around network requests
    const requestPatterns = [
      /requests\.(get|post|put|delete|patch)/gi
    ];
    
    let hasRequests = false;
    requestPatterns.forEach(pattern => {
      if (pattern.test(code)) {
        hasRequests = true;
      }
    });
    
    if (hasRequests && !code.includes('try:') && !code.includes('except')) {
      validator.addIssue('high', 'missing_error_handling', 
        'Network requests without error handling');
    }
    
    // Check for specific HTTP status code handling
    if (code.includes('raise_for_status()')) {
      // Good - using raise_for_status()
    } else if (hasRequests && !code.includes('status_code') && !code.includes('raise_for_status')) {
      validator.addIssue('medium', 'missing_status_check', 
        'No HTTP status code checking for requests');
    }
    
    // Check for generic exception handling
    if (code.includes('except:') && !code.includes('except Exception')) {
      validator.addIssue('medium', 'generic_exception_handling', 
        'Generic exception handling without specific exception types');
    }
  }
}

/**
 * Performance validation rule
 */
class PerformanceRule {
  get name() {
    return 'performance';
  }

  async validate(code, context, validator) {
    // Check for request timeouts
    if (code.includes('requests.') && !code.includes('timeout=')) {
      validator.addIssue('medium', 'missing_timeout', 
        'No timeout specified for requests');
    }
    
    // Check for rate limiting
    const requestCount = (code.match(/requests\.(get|post|put|delete|patch)/gi) || []).length;
    if (requestCount > 3 && !code.includes('time.sleep') && !code.includes('rate_limit')) {
      validator.addIssue('medium', 'missing_rate_limiting', 
        'Multiple requests without rate limiting');
    }
    
    // Check for session reuse
    if (requestCount > 1 && !code.includes('Session') && !code.includes('session')) {
      validator.addIssue('low', 'missing_session_reuse', 
        'Multiple requests without session reuse');
    }
  }
}

/**
 * Code quality validation rule
 */
class CodeQualityRule {
  get name() {
    return 'code_quality';
  }

  async validate(code, context, validator) {
    // Check for function definitions
    if (!code.includes('def ')) {
      validator.addIssue('medium', 'missing_functions', 
        'Code should be organized into functions');
    }
    
    // Check for documentation
    if (code.includes('def ') && !code.includes('"""') && !code.includes("'''")) {
      validator.addIssue('low', 'missing_documentation', 
        'Functions should have docstrings');
    }
    
    // Check for imports at top
    const importLines = code.split('\n').filter(line => 
      line.trim().startsWith('import ') || line.trim().startswith('from ')
    );
    
    if (importLines.length > 0) {
      const firstImportIndex = code.indexOf(importLines[0]);
      const firstFunctionIndex = code.indexOf('def ');
      
      if (firstFunctionIndex !== -1 && firstImportIndex > firstFunctionIndex) {
        validator.addIssue('low', 'imports_not_at_top', 
          'Imports should be at the top of the file');
      }
    }
    
    // Check for print statements (should use logging in production)
    const printCount = (code.match(/print\s*\(/g) || []).length;
    if (printCount > 2) {
      validator.addIssue('low', 'excessive_print_statements', 
        'Consider using logging instead of print statements');
    }
  }
}

/**
 * API usage validation rule
 */
class ApiUsageRule {
  get name() {
    return 'api_usage';
  }

  async validate(code, context, validator) {
    // Check for proper headers
    if (code.includes('requests.') && !code.includes('headers=')) {
      validator.addIssue('medium', 'missing_headers', 
        'API requests should include proper headers');
    }
    
    // Check for content-type in POST requests
    if (code.includes('requests.post') && !code.includes('Content-Type')) {
      validator.addIssue('low', 'missing_content_type', 
        'POST requests should specify Content-Type header');
    }
    
    // Check for user agent
    if (code.includes('requests.') && !code.toLowerCase().includes('user-agent')) {
      validator.addIssue('low', 'missing_user_agent', 
        'Requests should include User-Agent header');
    }
    
    // Check for JSON handling
    if (code.includes('application/json') && !code.includes('json=')) {
      validator.addIssue('low', 'improper_json_handling', 
        'JSON requests should use json parameter instead of data');
    }
  }
}

/**
 * Documentation validation rule
 */
class DocumentationRule {
  get name() {
    return 'documentation';
  }

  async validate(code, context, validator) {
    // Check for module-level docstring
    if (code.length > 100 && !code.startsWith('"""') && !code.startsWith("'''")) {
      validator.addIssue('low', 'missing_module_docstring', 
        'Module should have a docstring explaining its purpose');
    }
    
    // Check for function documentation
    const functionMatches = code.match(/def\s+\w+\([^)]*\):/g) || [];
    functionMatches.forEach(match => {
      const funcStart = code.indexOf(match);
      const nextDef = code.indexOf('def ', funcStart + 1);
      const funcEnd = nextDef !== -1 ? nextDef : code.length;
      const funcCode = code.substring(funcStart, funcEnd);
      
      if (!funcCode.includes('"""') && !funcCode.includes("'''")) {
        validator.addIssue('low', 'missing_function_docstring', 
          `Function ${match} should have a docstring`);
      }
    });
    
    // Check for inline comments explaining complex logic
    const complexPatterns = [
      /\w+\s*\[\s*\w+\s*\]/g,  // List/array access
      /\.\s*get\s*\(/g,          // Dictionary access
      /for\s+\w+\s+in\s+.*:/g   // Loops
    ];
    
    let complexityScore = 0;
    complexPatterns.forEach(pattern => {
      const matches = code.match(pattern) || [];
      complexityScore += matches.length;
    });
    
    if (complexityScore > 10) {
      const commentCount = (code.match(/#.*$/gm) || []).length;
      if (commentCount < complexityScore / 4) {
        validator.addIssue('low', 'insufficient_comments', 
          'Complex code should have more explanatory comments');
      }
    }
  }
}

/**
 * Validate code from file
 * 
 * @param {string} filePath - Path to Python file
 * @param {Object} context - Context information
 * @returns {Object} Validation results
 */
async function validateCodeFile(filePath, context = {}) {
  try {
    const code = await fs.readFile(filePath, 'utf8');
    const validator = new CodeValidator();
    return await validator.validate(code, context);
  } catch (error) {
    return {
      valid: false,
      error: `Failed to read file: ${error.message}`,
      issues: [{
        severity: 'critical',
        type: 'file_error',
        message: error.message
      }]
    };
  }
}

/**
 * Validate generated code against HAR context
 * 
 * @param {string} code - Generated Python code
 * @param {string} harPath - Path to HAR file
 * @returns {Object} Validation results
 */
async function validateAgainstHar(code, harPath) {
  try {
    // Read and analyze HAR file
    const harData = JSON.parse(await fs.readFile(harPath, 'utf8'));
    const entries = harData.log?.entries || [];
    
    // Extract context from HAR
    const context = {
      apiEndpoints: entries.map(entry => ({
        url: entry.request?.url,
        method: entry.request?.method,
        headers: entry.request?.headers || []
      })),
      hasAuthentication: entries.some(entry => 
        entry.request?.headers?.some(h => 
          h.name.toLowerCase().includes('auth') || h.name.toLowerCase().includes('token')
        )
      ),
      requestCount: entries.length
    };
    
    // Validate code
    const validator = new CodeValidator();
    return await validator.validate(code, context);
    
  } catch (error) {
    return {
      valid: false,
      error: `Failed to analyze HAR: ${error.message}`,
      issues: [{
        severity: 'critical',
        type: 'har_analysis_error',
        message: error.message
      }]
    };
  }
}

/**
 * Run Python syntax check
 * 
 * @param {string} code - Python code to check
 * @returns {Object} Syntax check results
 */
function checkPythonSyntax(code) {
  try {
    // Write to temporary file
    const tempFile = path.join(__dirname, 'temp_syntax_check.py');
    fs.writeFileSync(tempFile, code);
    
    // Check syntax
    const result = execSync(`python3 -m py_compile ${tempFile}`, { 
      encoding: 'utf8',
      stdio: 'pipe'
    });
    
    // Clean up
    fs.unlinkSync(tempFile);
    
    return {
      valid: true,
      message: 'Syntax is valid'
    };
    
  } catch (error) {
    return {
      valid: false,
      message: error.stderr || error.message,
      line: extractErrorLine(error.stderr || error.message)
    };
  }
}

/**
 * Extract line number from Python error message
 * 
 * @param {string} errorMessage - Error message
 * @returns {number|null} Line number
 */
function extractErrorLine(errorMessage) {
  const match = errorMessage.match(/line (\d+)/);
  return match ? parseInt(match[1]) : null;
}

// CLI interface
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.log('Usage: node validate-generated-code.js <python-file> [har-file]');
    console.log('');
    console.log('Examples:');
    console.log('  node validate-generated-code.js generated_code.py');
    console.log('  node validate-generated-code.js generated_code.py network.har');
    process.exit(1);
  }
  
  const pythonFile = args[0];
  const harFile = args[1];
  
  validateCodeFile(pythonFile, {})
    .then(result => {
      console.log('Validation Results:');
      console.log('==================');
      console.log(`Valid: ${result.valid}`);
      console.log(`Score: ${result.score}/100`);
      console.log('');
      
      if (result.summary.total > 0) {
        console.log('Issues by Severity:');
        Object.entries(result.summary).forEach(([severity, count]) => {
          if (count > 0 && severity !== 'total') {
            console.log(`  ${severity}: ${count}`);
          }
        });
        console.log('');
      }
      
      if (result.recommendations.length > 0) {
        console.log('Recommendations:');
        result.recommendations.forEach(rec => {
          console.log(`  [${rec.priority.toUpperCase()}] ${rec.title}`);
          console.log(`    ${rec.description}`);
        });
        console.log('');
      }
      
      if (!result.valid) {
        process.exit(1);
      }
    })
    .catch(error => {
      console.error('Validation failed:', error.message);
      process.exit(1);
    });
}

module.exports = {
  CodeValidator,
  validateCodeFile,
  validateAgainstHar,
  checkPythonSyntax
};